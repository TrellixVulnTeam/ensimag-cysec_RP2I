
Tamarin compiled from source.

https://github.com/tamarin-prover/manual/tree/master/code


## Usage

```bash
tamarin-prover --prove tutorial.spthy
tamarin-prover interactive {--auto-sources,--diff} tutorial.spthy
```

## Notes

```tamarin
Out( aenc{'1', ~k}pkS
Eq(fst(adec(request, ~ltkS)), '1')  // check that rhe first element of the request is equal to '1' to validate the decryption

// log the session-key setup requests received by servers
AnswerRequest($S, snd(adec(request, ~ltkS)) ?

SessKeyC(S, k) @ #i  // session key 'k' with a server 'S' at time i
K(k) @ #j  // the adversary knows 'k'
not(Ex #r. LtkReveal(S) @ r)  // the adversary has not performed a long-term key reveal on 'S'
Ex #r. LtkReveal(S) @ r & r < i  // the intruder performed a long-term key reveal on 'S' before the key was setup.
Ex #a. AnswerRequest(S, k) @ a  // there is a server that answered the request
& (All #j. SessKeyC(S, k) @ #j ==> #i = #j) // and there is no other client that had the same request, INJECTIVE authentication ie. uniqueness
exists-trace
    "Ex x #i. Ba(x) @i
    "  // an event of the form Ba(x) can occur (transition)
All x #i. Ba(x) @ i ==> Ex #j. Aa(x) @ j & j < i  // each event of the form Ba(x) should be preceded by an event of the form Aa(x)
All x #i. Ca(x) @i ==> F  // no event of type Ca(x) can occur
[In(x)]--[Ba(x)]->[B(x)]  // same x can be send twice so [In(x), B(x)] can occur
All x #i #k. (Ba(x) @ i) & (Aa(x) @ k) ==> Ex #j. Rev(x) @ j & j < i  // the adversary can learn an 'x' generated by the rule GenA, only if it was "revealed" before using the rule Rev
restriction once:
" 
All #i #j. Bigger() @ i & Bigger() @ j ==> #i = #j 
"  // at most one event 'Bigger'
```

the sort prefix ie. **#** for the temporal variables 'i' and 'j' is optional

For universally quantified variables ie. **All**, one has to check that they all occur **in
an action constraint right after the quantifier** and that the **outermost logical operator
inside the quantifier is an *implication***.

For existentially quantified variables ie. **Ex**, one has to check that they all occur **in
an action constraint right after the quantifier** and that the **outermost logical
operator inside the quantifier is a *conjunction***.

axioms ie. **restriction** that restrict the set of considered traces.

Without ~x : always generate facts of the form A(x) with the **same value** 'x's.
With ~x : always generate facts of the form A(x) with **a new** 'x' value each time.