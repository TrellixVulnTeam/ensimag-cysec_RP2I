-- Exercice 1 --


-- Exercice 2 --

-- Exercice 3 --

Question 1)
Possible behaviours for gets :
On success, the function returns str.
If the end-of-file is encountered while attempting to read a character, the eof indicator is set (feof). If this happens before any characters could be read, the pointer returned is a null pointer (and the contents of str remain unchanged).
If a read error occurs, the error indicator (ferror) is set and a null pointer is also returned (but the contents pointed by str may have changed).

Question 2)
Attack : to crash the execution
Enter a long string (for instance : "*ùmlkjtrezqwxcvhjiolùmjytrdszedfguiklm$=)àç_ytrezaqsdfghjklmlnbvcxwqazertyuioplkjhgfdcvbn")

=> When the user types a long string, gets will copy all the string in the variable Password without verifying the entry is shorter than the size of the variable. So, gets written the first characters of the long string in Password, and the others characters in the next memory : it will rewrite a part of the stack and, if the string is enough long, rewrite the return address of the function and will raise an error at the compilation ("Erreur de segmentation (core dumped)").


Attack : to get authenticated without entering twice the correct password
First time : enter the good password
Second time : CRTL-D

=> The first time, we enter the password, the password is stored in the variable Password created in the function IsPasswordOK(). The second time, when we call the function IsPasswordOK(), the variable Password is allocated at the same address than previously. As there are any instanciation of the variable, his default value is the previous one, i.e. the previous password written by the user. Then, we call the function gets() and send to this function "CTRL-D", which corresponds to the end-of-file character. As see in the first question, when the function fgets encounter the end-of-file before any characters couls be read, the contents of the variable Password remain unchanged. Then, when we compare Password with the good password, we compare in reality the good password and the password which the user types the first time and which are always stored in Password. So, the comparaison succeed.

Question 3)
Possible behaviours for fgets :
On success, the function returns str.
If the end-of-file is encountered while attempting to read a character, the eof indicator is set (feof). If this happens before any characters could be read, the pointer returned is a null pointer (and the contents of str remain unchanged).
If a read error occurs, the error indicator (ferror) is set and a null pointer is also returned (but the contents pointed by str may have changed).

=> Same behaviour than gets for return value

Differences with gets :
Notice that fgets is quite different from gets: not only fgets accepts a stream argument, but also allows to specify the maximum size of str and includes in the string any ending newline character.

To replace gets by fgets in the code, we need to remove the ending newline character at the end of the password if it exists.

unsigned int size=12;
int IsPasswordOK(void)
{
	char Password[size];
	//gets(Password);
	fgets(Password, size, stdin);
	if(Password[strlen(Password) - 1] == '\n') {
		Password[strlen(Password) - 1] = 0;
	}
	return 0 == strcmp(Password, "goodpass");
}

As previously, we can get authenticated without entering twice the correct password. To avoid this, we need to verify than fgets don't encounter the end-of-file before any characters could be read. For this, we must verify the value of the returned pointer :

unsigned int size=12;
int IsPasswordOK(void)
{
	char Password[size];
	// Verification than the returned pointer is not NULL
	if (fgets(Password, size, stdin) == NULL) {
		return 0;
	}
	if(Password[strlen(Password) - 1] == '\n') {
		Password[strlen(Password) - 1] = 0;
	}
	return 0 == strcmp(Password, "goodpass");
}

The second attack (to crash the execution) is not possible anymore : fgets only copy at most the number of characters precised in parameter, that avoid stack overflow.
